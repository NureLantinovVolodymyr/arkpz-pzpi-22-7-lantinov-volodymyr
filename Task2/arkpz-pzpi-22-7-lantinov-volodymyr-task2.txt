МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


Кафедра «Програмної інженерії»






ЗВІТ

З Лабораторної роботи № 2 з дисципліни
«Аналіз та рефакторинг коду»









Виконав
ст. гр. ПЗПІ-22-7
Лантінов Володимир	Перевірив
ст. викладач каф. ПІ Сокорчук І. П.








Харків 2024
 
1	Вступ

1.1	Тема


Розробка бази даних для серверної частини програмної системи та прикладного програмного інтерфейсу (АРІ).

1.2	Мета

Розробити базу даних для серверної частини програмної системи та прикладного програмного інтерфейсу.

2	Розробка діаграм

2.1	Розробка UML діаграми прецедентів для серверної частини системи

Для акторів UML діаграми було обрано адміністратора системи (Admin) та користувача (User). Адміністратор відповідає за керування транспортними засобами, користувачами та переглядом даних із сенсорів. Користувачі мають змогу переглядати дані про призначені їм транспортні засоби та маршрути.
Для прецедентів було обрано такі сценарії:
•	Авторизація користувача.
•	Перегляд інформації про транспортні засоби.
•	Перегляд маршрутів та стану транспортного засобу.
•	Управління користувачами (CRUD операції, доступно для адміністратора).
•	Управління транспортними засобами (CRUD операції, доступно для адміністратора).
•	Перегляд даних із сенсорів у реальному часі.
На основі цих сценаріїв створено UML діаграму прецедентів (див. рис. 2.1), яка ілюструє взаємодію акторів із серверною частиною системи.
 

 
Рис. 2.1 – UML діаграма прецедентів

2.2	Розробка ER діаграми даних

Для розробки бази даних було створено ER діаграму, яка відображає основні сутності системи та їх взаємозв’язки. Основними сутностями є:
•	Vehicles (Транспортні засоби) — містить інформацію про транспортні засоби, включаючи модель, номерний знак, рік випуску та статус.
•	Users (Користувачі) — таблиця для зберігання даних про користувачів, включаючи їхні ролі (користувач або адміністратор).
•	Routes (Маршрути) — зберігає інформацію про маршрути транспортних засобів, такі як початкова та кінцева точки, а також дистанцію.
•	Sensors (Сенсори) — містить дані, отримані від сенсорів (наприклад, температура чи тиск), з прив’язкою до транспортного засобу.
•	UserVehicles (Призначення транспортних засобів) — відображає, які транспортні засоби призначені певним користувачам.
(див. рис. 2.2).

 
Рис. 2.2 – ER діаграма даних

3.	Розробка бази даних

3.1	Розроблення бази даних програмної системи 

Код наведено у додатку А
Розробка бази даних для програмної системи управління транспортними засобами здійснюється з урахуванням вимог щодо зберігання та обробки даних про транспортні засоби, користувачів, маршрути, сенсори та інші аспекти системи. Для цієї мети було вибрано реляційну базу даних, яка забезпечує чітку організацію та зв'язок між сутностями, необхідними для роботи програмної системи.
Структура бази даних складається з наступних основних таблиць:
•	3.1.1 Таблиця Users: Містить інформацію про користувачів системи. Кожен запис представляє дані про користувача, такі як ім’я, електронна пошта, телефон, а також роль у системі (адміністратор, водій чи користувач).
•	3.1.2 Таблиця Vehicles: Зберігає інформацію про транспортні засоби, включаючи модель, номерний знак, рік випуску, статус (активний/неактивний) та інші технічні параметри.
•	3.1.3 Таблиця Routes: Містить дані про маршрути, такі як початкова і кінцева точка, відстань та транспортний засіб, який виконує маршрут.
•	3.1.4 Таблиця Sensors: Зберігає дані, отримані від сенсорів, прив'язаних до транспортних засобів. Це можуть бути дані про температуру, тиск у шинах або інші параметри, зібрані у реальному часі.
•	3.1.5 Таблиця UserVehicles: Використовується для зберігання інформації про те, які транспортні засоби призначені певним користувачам.
Зв’язки між таблицями
Для забезпечення інтеграції даних та підтримки зв'язків між сутностями в базі даних використовуються зовнішні ключі:
•	Таблиця Users пов’язана з таблицею UserVehicles через user_id.
•	Таблиця Vehicles пов’язана з таблицями Routes, Sensors та UserVehicles через vehicle_id.
•	Таблиця Routes зберігає інформацію про транспортні засоби, які виконують маршрути, через поле vehicle_id.
Використання ORM для взаємодії з базою даних
Для зручної роботи з базою даних використовується ORM (Object-Relational Mapping) інструмент, наприклад, Sequelize для Node.js. Це спрощує визначення моделей, валідацію даних, а також підтримує функціональність для роботи з реляційними зв’язками.
Таке проектування бази даних забезпечує ефективне зберігання, обробку та масштабування даних, необхідних для роботи програмної системи управління транспортними засобами.
Використання Mongoose для роботи з MongoDB
Mongoose використовується для взаємодії з базою даних MongoDB, спрощуючи процес створення моделей, валідації даних та виконання операцій з документами й колекціями. Цей інструмент забезпечує гнучке визначення схем даних і пропонує широкий набір методів для роботи з ними, а також підтримує зв'язки між документами за допомогою властивості ref.
Таке підходження до проектування бази даних сприяє ефективному зберіганню та обробці даних, забезпечуючи можливість гнучкого масштабування системи в майбутньому.

3.2	Розробка діаграми структури бази даних

Після створення бази даних, була розроблена діаграма структури бази даних (див. рис. 3.1).

 
Рис. 3.1 – діаграма структури бази даних

4	Розробка серверної частини

4.2	Розробка АРІ для взаємодії серверної частини з клієнтами
Для реалізації серверної частини програми було розроблено наступні маршрути та контролери, що забезпечують функціонал реєстрації, авторизації, активації акаунтів, а також управління сесіями користувачів.
4.2.1	Маршрути: 
•	POST /login – маршрут для входу користувача в систему.
•	POST /logout – маршрут для виходу користувача з облікового запису.
•	POST /registration – маршрут для реєстрації нового користувача.
•	GET /users – маршрут для отримання списку всіх користувачів (доступний лише авторизованим користувачам).
4.2.2	Контролери:
UserController:
•	login: Авторизація користувача з перевіркою на відповідність введених даних до збережених у базі даних. При успішному вході також генерується refresh токен.
•	logout: Виконує авторизацію користувача з перевіркою правильності даних. При успішному вході генерується refresh-токен в cookies.
•	registration: Реалізує реєстрацію нового користувача з перевіркою валідності даних. У разі успішної реєстрації створюється refresh-токен, який зберігається в cookies.
•	getUsers: Дозволяє адміністратору переглядати список усіх користувачів системи
4.2.3	Код реалізації:
Наведено у додатку Б
Цей набір маршрутів і контролерів забезпечує базову функціональність
для реєстрації та авторизації користувачів, а також їх активацію і управління сесією.
Тепер використовуючи створене АРІ було розроблено програмну реалізацію через Swagger (див. рис. 4.1).

  
Рис. 4.1 – програмна реалізація для АРІ

5	Висновок

Під час виконання лабораторної роботи було розроблено UML діаграму прецедентів для серверної частини та ER діаграму даних. На основі цих діаграм була побудована база даних для програмної системи. Після цього була створена діаграма структури бази даних, яка відображає її організацію та зв’язки між таблицями. Далі були розроблені функції для роботи з цією базою даних та API для взаємодії серверної частини з клієнтськими додатками. Завершальним етапом стало створення програмної реалізації розробленого API.
Посилання на відео: 



Додаток А

1  const express = require('express');
2  const mongoose = require('mongoose');
3  const bodyParser = require('body-parser');
4  
5  // Підключення до MongoDB
6  mongoose.connect('mongodb://localhost:27017/your_project', {
7    useNewUrlParser: true,
8    useUnifiedTopology: true,
9  });
10 
11 // Створення схем та моделей
12 
13 // Схема користувача
14 const userSchema = new mongoose.Schema({
15   first_name: { type: String, required: true },
16   last_name: { type: String, required: true },
17   email: { type: String, required: true, unique: true },
18   password_hash: { type: String, required: true },
19   phone: String,
20   role: { type: String, enum: ['User', 'Admin'], required: true },
21   created_at: { type: Date, default: Date.now },
22   updated_at: { type: Date, default: Date.now },
23 });
24 
25 const User = mongoose.model('User', userSchema);
26 
27 // Схема записів про активності
28 const activitySchema = new mongoose.Schema({
29   user_id: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
30   type: { type: String, required: true },
31   duration: Number,
32   date: { type: Date, default: Date.now },
33   created_at: { type: Date, default: Date.now },
34   updated_at: { type: Date, default: Date.now },
35 });
36 
37 const Activity = mongoose.model('Activity', activitySchema);
38 
39 // Схема для сповіщень
40 const notificationSchema = new mongoose.Schema({
41   user_id: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
42   message: { type: String, required: true },
43   type: { type: String, enum: ['Reminder', 'Alert', 'Info'], required: true },
44   status: { type: String, enum: ['Sent', 'Pending', 'Failed'], default: 'Pending' },
45   created_at: { type: Date, default: Date.now },
46   updated_at: { type: Date, default: Date.now },
47 });
48 
49 const Notification = mongoose.model('Notification', notificationSchema);
50 
51 // Ініціалізація Express
52 const app = express();
53 app.use(bodyParser.json());
54 
55 // Маршрут для створення користувача
56 app.post('/users', async (req, res) => {
57   try {
58     const user = new User(req.body);
59     await user.save();
60     res.status(201).json(user);
61   } catch (error) {
62     res.status(400).json({ message: error.message });
63   }
64 });
65 
66 // Маршрут для отримання всіх користувачів
67 app.get('/users', async (req, res) => {
68   try {
69     const users = await User.find();
70     res.status(200).json(users);
71   } catch (error) {
72     res.status(400).json({ message: error.message });
73   }
74 });
75 
76 // Маршрут для створення активності
77 app.post('/activities', async (req, res) => {
78   try {
79     const activity = new Activity(req.body);
80     await activity.save();
81     res.status(201).json(activity);
82   } catch (error) {
83     res.status(400).json({ message: error.message });
84   }
85 });
86 
87 // Маршрут для отримання всіх активностей
88 app.get('/activities', async (req, res) => {
89   try {
90     const activities = await Activity.find().populate('user_id', 'first_name last_name email');
91     res.status(200).json(activities);
92   } catch (error) {
93     res.status(400).json({ message: error.message });
94   }
95 });
96 
97 // Запуск сервера
98 const PORT = 3000;
99 app.listen(PORT, () => {
100   console.log(`Server is running on port ${PORT}`);
101 }); 
Додаток Б

1  const UserModel = require("../models/user-model");
2  const bcrypt = require("bcrypt");
3  const uuid = require("uuid");
4  
5  const tokenService = require("./token-service");
6  const UserDto = require("../dtos/user-dto");
7  const ApiError = require("../exceptions/api-error");
8  
9  class UserService {
10   async registration(email, password) {
11     const candidate = await UserModel.findOne({ email });
12     if (candidate) {
13       throw ApiError.BadRequest(
14         `User with email address ${email} already exists`
15       );
16     }
17     const hashPassword = await bcrypt.hash(password, 3);
18     const activationLink = uuid.v4(); // v34fa-asfasf-142saf-sa-asf
19  
20     const user = await UserModel.create({
21       email,
22       password: hashPassword,
23       activationLink,
24     });
25  
26     const userDto = new UserDto(user); // id, email, isActivated
27     const tokens = tokenService.generateTokens({ ...userDto });
28     await tokenService.saveToken(userDto.id, tokens.refreshToken);
29  
30     return { ...tokens, user: userDto };
31   }
32  
33   async activate(activationLink) {
34     const user = await UserModel.findOne({ activationLink });
35     if (!user) {
36       throw ApiError.BadRequest("Incorrect activation link");
37     }
38     user.isActivated = true;
39     await user.save();
40   }
41  
42   async login(email, password) {
43     const user = await UserModel.findOne({ email });
44     if (!user) {
45       throw ApiError.BadRequest("User with this email was not found");
46     }
47     const isPassEquals = await bcrypt.compare(password, user.password);
48     if (!isPassEquals) {
49       throw ApiError.BadRequest("Invalid password");
50     }
51     const userDto = new UserDto(user);
52     const tokens = tokenService.generateTokens({ ...userDto });
53  
54     await tokenService.saveToken(userDto.id, tokens.refreshToken);
55     return { ...tokens, user: userDto };
56   }
57  
58   async logout(refreshToken) {
59     const token = await tokenService.removeToken(refreshToken);
60     return token;
61   }
62  
63   async refresh(refreshToken) {
64     if (!refreshToken) {
65       throw ApiError.UnauthorizedError();
66     }
67     const userData = tokenService.validateRefreshToken(refreshToken);
68     const tokenFromDb = await tokenService.findToken(refreshToken);
69     if (!userData || !tokenFromDb) {
70       throw ApiError.UnauthorizedError();
71     }
72     const user = await UserModel.findById(userData.id);
73     const userDto = new UserDto(user);
74     const tokens = tokenService.generateTokens({ ...userDto });
75  
76     await tokenService.saveToken(userDto.id, tokens.refreshToken);
77     return { ...tokens, user: userDto };
78   }
79  
80   async getAllUsers() {
81     const users = await UserModel.find();
82     return users;
83   }
84 }
85  
86 module.exports = new UserService();
